#완전탐색
1)입력 범위가 작고 (1억==1초)
2)전체 문제를 부분 문제로 쪼갤 수 있으며, 부분 문제를 푸는 데 
이전까지의 선택이 이후의 선택을 할 때 고려해야할 필요가 없을 경우(최적부분구조).
재귀함수를 쓰는 게 일반적이다.

풀때 1)중복을 허용하는가? 2)순서가 고려되는가?
1-1)허용하면->처음부터 뽑는다.
1-2)허용 않으면->뽑혔던 것들을 전역 변수로 저장한다.(백트래킹)
2-1)고려되면->순열.
2-2)고려 안하면->조합. 순서를 고정한다.
특정 원소를 포함할지 말지 결정하는 문제(2^n 문제)도 완전탐색으로 풀 수 있다.


#백트래킹
1)완전탐색으로 풀수 있는 문제 중 
2)모든 순열이나 조합을 사전순으로 만들어야 하는 문제에 사용.
재귀로 모든 답을 차례로 만들며, 답이 완성되면 재귀 스택을 빼내 바로 이전으로 돌린다.

속도를 줄이는 법으로 미리 원소를 캐싱하는 방법이 있는데
특정 원소가 선택되었는지 여부를 저장해둔다.
좌표계의 위치를 따질 때도 가로, 세로 등등 겹치는 것이 있는지 따로 저장한다.
대부분 전체 원소 개수 n의 배수만큼 빨라진다. 대신 메모리 초과 항상 확인

순열을 구하는 문제의 경우 next_permutation을 활용할 수 있다.
배열을 사전순으로 바로 다음에 해당하는 백트래킹 결과로 바꿔준다.
중복된 수도 잘 처리해주며, 
조합을 따질 때도 {0,0,0,1,1}과 같은 배열을 대신 사용하면 처리가 가능하다.

대표 유형 1) 겹치지 않는 체스말 문제
대표 유형 2) 순열, 조합 구하기


#분할정복
1)문제를 재귀함수로 분할이 용이하고,
2)분할된 문제가 원래 문제와 성격이 동일하고,
3)최소단위 문제를 쉽고 빠르게 풀 수 있는 경우 사용한다.

다음의 순서로 진행된다.
1)문제를 적절한 형태의 하위 문제로 더 이상 나눌 수 없을 때까지 나눈다.
2)최소 단위 문제의 해를 구한다.
3)구한 해를 나눈 순서대로 결합해가며 전체 답을 구한다.


#동적계획법
-최적 부분 구조
전체 문제를 같은 부분 문제로 조각냈을 때,
어느 부분 문제에 도달할 때까지 있었던 모든 선택이 이후의 선택에 영향을 주지 못하며
따라서 남은 부분 문제는 항상 최적으로 풀어도 상관 없는 문제 구조
즉 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 구할 수 있는 문제 구조

대표 유형 1) LIS
대표 유형 2) 01 배낭 문제
대표 유형 3) 최적화 문제
대표 유형 4) 경우의 수 구하기 문제

#기본 자료구조
1.해시
문자-숫자 짝으로 자료를 저장해야 할 때 사용
탐색 방법 :
map<~,~> m;
if(m.find(key)==m.end()){//찾는 게 없는가?
    m.insert(make_pair(clothes[i][1],1));//없으면 넣고
}else{
    m[clothes[i][1]]++; //있으면 숫자 증가
}

map<~, ~>::iterator it;
for (it = m.begin(); it != m.end(); it++) {
    ~
}
순회 방법 :
map<~, ~>::iterator it;
for (it = m.begin(); it != m.end(); it++) {
    ~
}

2.스택/큐/우선순위큐(힙)
셋다 순차적으로 진행되는 문제에 주로 사용 ex) 초단위 계산, 절차대로 작업
스택 : 나중에 넣은것부터 변화를 줄 경우
큐 : 처음에 넣은것부터 변화를 줄 경우
우선순위큐(힙) : 원소 추가시마다 정렬을 새로 해야 할 경우
우선순위 큐를 반으로 쪼개 두개의 우선순위큐를 만들고 서로 정렬을 반대 규칙으로 하면,언제나 중앙값을 찾을 수 있는 우선순위큐를 만들 수 있다. 긴쪽의 탑. 삽입시 양 쪽 탑을 비교해서 적절한 큐에 넣고, 최대값과 최소값은 루트를 탐색한다.

3.부분 합, 누적 합

4.비트마스크

5.문자열

6.정렬
sort 함수를 사용하면 된다.
펑터를 이용해 정렬 규칙을 바꿔 원하는 정렬 형태를 만들 수 있다.


#트리
1.이진 탐색 트리

2.구간 트리 (세그먼트 트리)

3.상호 배타적 트리 (분리 집합 ,union-find)
집합 표현시 사용. 배열 하나 두고 해당 원소가 속한 원소의 집합의 대표 원소를 반환하는 배열 parent를 둬 해당 원소가 어디에 속하는지를 확인.
집합 표현할 때 쓰로 주로 최소 스패닝 트리 다룰 때 쓴다.
struct NaiveDisjointSet { 
    vector<int> parent; 
    NaiveDisjointSet(int n): parent(n) { 
        for (int i=0; i < n; i++) parent[i]=i; 
    } 
    int find (int u) { 
        if (u == parent[u]) return u;  
        return parent[u]=find(parent[u]); 
    } 
    bool merge (int u, int v){
        u = find(u); v = find(v); 
        if (u == v) return false; 
        parent[u] = v; 
        return true;
    } 
};

4.트라이



#그래프

1.DFS/BFS
1)DFS
모든 정점을 방문해야 할 때 사용(방문할 필요 없는 정점 많으면 사용 x)
재귀적으로 구현, 백 트레킹 방식->반드시 활용할 것

2)DFS
A->B로 가는 임의 최단 경로 탐색시 사용
큐를 이용할 것

2.최단경로
1)0-1 BFS (가중치 0-1일때만)
2)다익스트라
3)벨만포드
4)플로이드

3.최소 스패닝 트리
1)크루스칼 최소 스패닝 트리
예시 : https://programmers.co.kr/learn/courses/30/lessons/42861
그리디 알고리즘의 대표 예시, 시간 복잡도 O(ElogE).
모든 정점이 연결된 경우가 아니라면 사용한다.
간선을 가중치 순으로 정렬하고, 간선을 n-1개만큼 선택한다.
이때 사이클이 발생하는 경우는 제외하고 선택해야 한다.
사이클을 판별할 때 유니온파인드 셋을 쓰면 간단하다.
각각의 정점이 하나의 집합이라고 생각하고, 간선으로 연결될 때마다 집합을 합친다.
만약 이미 합쳐진 두 정점을 선택할 경우 수를 세지 않는데,
이 과정이 유니온파인드의 merge 함수와 정확히 일치한다.
2)프림 최소 스패닝 트리
크루스칼과 비슷한 그리디 알고리즘.
모든 정점이 서로 연결된 경우에 크루스칼보다 빠르게 동작한다.
...추가바람

4.네트워크 유량


#탐욕법
모든 경우에 지금
각 단계에서 탐욕법으로 선택한 부분 문제의 최적해들을 포함하는 전체 최적해가 
항상 존재하면 해당 문제는 탐욕적 선택 속성이 있는 문제는
증명은 다음과 같이 진행
1)탐욕법이 "속성 A를 갖는 원소를 포함하는 최적해가 반드시 존재한다"라면
2)"속성 A를 갖지 않는 원소를 포함하는 최적해가 있다"고 가정
3)이후 둘을 비교하여 2)의 경우가 최적해라면 1)의 경우도 최적해가 되어야 함을 증명
탐욕법을 적용할 때 선택에 있어 손해를 볼 일이 없음을 증명한다
주로 나오는 유형
1)부분 배낭 문제
2)스케줄링 문제
3)최소 스패닝 트리





#정수, 기하
1)이분탐색
오버플로우 주의
최소값의 최댓값




#기타

