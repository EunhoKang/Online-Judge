#기본 코드 작성(c++)

*표준 입출력
기본적으로 scanf/printf 또는 cin/cout를 사용.
scanf/printf        |    cin/cout
C style             |    C++ style
C 버퍼 사용          |    C++ 버퍼 사용
C++ string 처리 불가 |    C++ string 처리 가능
더 빠름              |    더 느림


*스트림
https://uxicode.tistory.com/entry/스트림-stream-이란
데이터,패킷,비트 등의 일련의 연속성을 갖는 흐름을 의미한다.
즉 스트림의 정체는 데이터 자체이며, 
이 데이터를 주고받는 여러 장치들을 통일된 방식으로 다루기 위한 가상의 개념이다.

기본적으로 프로그램과 입출력을 담당하는 키보드, 모니터는 연결되어 있지 않음.
이를 단방향으로 연결해주고 둘 사이에서 중계하는 것이 표준 입출력 스트림.
단방향이므로 당연히 입력, 출력 스트림은 따로 있고, 프로그램 시작시 자동 생성.
주로 사용하는 stdin, stdout, stderr 등이 대표적인 표준 입출력 스트림.

스트림은 크게 텍스트 스트림, 이진 스트림 등으로 구별이 가능하다.
표준 입출력 스트림은 텍스트 스트림으로 문자열만을 처리한다.
텍스트 스트림은 공백 및 줄바꿈을 읽어 프로그램의 끝을 알리는데, 
이 때문에 C에서는 공백 문자를 읽어들이려면 추가적인 작업이 필요하다.


*버퍼
http://tcpschool.com/c/c_io_console
완충기억기. 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 
일시적으로 그 데이터를 보관하는 메모리의 영역. 큐의 일종이다.
이 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 버퍼링이라 부른다.

일반적으로 키보드 입력을 받으면 즉시 이를 변수로 저장하는 것이 아니라,
버퍼가 가득 차거나 개행 등의 특정 상황이 발생하면 
버퍼에 남아있던 지금까지의 입력을 스트림을 통해 전부 넘겨준다.
전송 작업을 적게 할 수 있어 더 효율적이고 입력 과정에서 수정 역시 용이.


*ios_base::sync_with_stdio(false); cin.tie(null);
https://jaimemin.tistory.com/1521
C++와 C에는 각각의 버퍼가 따로 존재하는데, 기본적으로 이 둘은 자동으로 동기화된다.
따라서 cout, cin, scanf, printf를 어떤 식으로 사용하든
멀티 쓰레드 환경에서 출력 순서가 보장이 되게 된다.

그러나 버퍼를 계속 동기화할 경우 입력이 많아지면 부하가 발생해 프로그램이 느려진다.
그런데 printf/scanf 와 cin/cout 를 같이 사용하지 않는다면 동기화가 필요하지 않다.
따라서 이 경우 최적화를 위해 ios_base::sync_with_stdio(false);를 통해
동기화를 해제하여 성능 향상을 꾀하는 것이다.

C,C++에는 입력 또는 출력 버퍼를 강제로 비우는 함수가 있는데,
이에 해당하는 함수가 각각 fflush(), ignore()이다. 편의상 flush 함수로 부른다.
일반적으로 cout/cin을 사용할 때, cin과 cout이 tie가 된 상태인데,
두 stream이 tie 된 상태에서는 입력을 받기 전에 출력 버퍼를 flush하게 된다.
일반적으로 cout은 출력 버퍼가 꽉 차거나 수동으로 flush하지 않으면 출력을 안하는데,
tie가 되어있을 경우 cin이 호출되는 순간 출력 버퍼를 flush 하여
자연스럽게 입출력이 될 수 있도록 하는 것.
그러나 코딩 테스트에서는 입력 버퍼에 푸쉬가 모두 끝나야 출력 버퍼를 사용하므로,
쓸데없이 발생하는 flush를 줄이는 것이 좋다. 이를 위해 cin.tie(0)를 사용한다.

동일한 이유로, endl를 코딩 테스트에서는 사용할 이유가 없다.
endl에는 개행뿐 아니라 버퍼를 flush하는 명령도 포함되어 있는데,
상술했듯 코딩 테스트에서는 flush를 할 필요가 없다.


*printf/scanf

-기본 입출력
int a;
scanf("%d \n",&a); printf("%d \n", a/b);
double b;
scanf("%d %f \n",&a,&b); printf("%f \n", a/b);

-문자열 처리
char * c[100];
scanf("%s \n", c); printf("%s \n",c);//c는 이미 포인터이므로 주소 연산자 x

-공백 포함하여 받기
char * c[100];
scanf("%[^\n]s", c); printf("%s \n",c);
또는
fgets(c,1000,stdin);//1:포인터,2:문자열 최대 크기(마지막 \0 포함),3:파일(스트림)

-소수점 자리 조정
printf("%.9f",a/b);//소수점 9자리까지 표기, 기본은 6자리

-갯수가 정해지지 않은 문자열을 모두 입력받는 방법
char * c[100];
while (scanf("%[^\n]s", c) != EOF){...}
또는
while (fgets(c, 100, stdin)){...}


*cin/cout

-기본 입출력 & 문자열 처리
int a;
cin>>a;cout<<a;
double b;
cin>>b;cout<<b;
string c;
cin>>c;cout<<c;

-공백 포함하여 받기
int a,temp;
cin>>a;
cin.ignore();//버퍼 비워서 이상한 값이 안 들어가도록 하기
getline(cin,temp);

-문자열을 배열로
vector<int> split(string s, char del){
    vector<int> res;
    stringstream ss(s);
    string tp;
    while(getline(ss,tp,del)){
        res.push_back(stoi(tp));
    }
    return res;
}

-소수점 자리 조정
cout << fixed;
cout.precision(6); //소수점 6자리까지 표기

-갯수가 정해지지 않은 문자열을 모두 입력받는 방법
string tree;
while(getline(cin,tree)){}


*bits/stdc++.h
모든 표준 라이브러리를 포함하는 헤더. 하나만 include 하면 된다.
컴파일 시간이 늘어나긴 하나 실행 시간에는 큰 차이가 없으니 
타이핑 시간을 절약하도록 하자.



#시간복잡도, 공간복잡도
시간복잡도 : 문제를 해결하는데 걸리는 시간과 입력의 함수 관계.
공간복잡도 : 문제를 해결하는데 필요한 공간과 입력의 함수 관계.


*점근 표기법
어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 방법.
대표적으로 다섯가지 표기법이 쓰이나,
빅오 표기법이 압도적으로 많이 쓰인다.
빅오 표기법은 수식의 계수와 낮은 차수의 항을 제외시키는 방법이다.
기호로는 O(x)와 같이 표기하며 x는 한개 혹은 그 이상의 변수로 이루어진 식이다.
ex) O(5N^2+3N)=O(N^2)

크기 n이 커질수록 가장 계수가 높은 항을 제외한 나머지 항과 계수는 
전체 값에 영향을 주지 못한다. 따라서 이를 제외하고 비교하는 것이다.
식의 값에 따라 상수항이 나오면 상수 시간 알고리즘,
로그 함수로 표현되면 로그 시간 알고리즘,
1차항을 가지면 선형 시간 알고리즘,
2차 이상의 계수를 가지면 다항 시간 알고리즘,
지수함수로 표현되면 지수 시간 알고리즘 등으로 표현한다.


*시간복잡도 수식화
단순 비교, 대입, 사칙 연산을 기본 단위(1)로 취급할 때,
이러한 계산이 입력의 크기 N에 대해 얼마나 실행되는지를 계산하고
이를 N에 대한 수식으로 표시한다.
ex)
while(int i=0;i<n;++i)a++;  =>  O(n)


*공간복잡도 수식화
배열, 큐, 스택 등에 저장되는 최대 갯수만 계산한다.
이후 이 함수를 빅오표기법으로 표현한다.
각 변수형마다 필요한 바이트는 다음과 같다.
char        1byte
int         4byte
float       4byte
double      8byte
long long   8byte
long double 8byte


*매직 넘버
https://blog.encrypted.gg/724?category=773649
프로그래밍 문제를 풀 때 어떤 알고리즘을 쓸지 정할 때 기준이 되는 숫자들이다.

1.1초=1억
위에 언급된 기본단위 계산이 1억번 발생하면 최대 1초가 걸린다.
즉 빅오 표기법으로 만든 함수에 입력의 최대 크기를 넣은 값이 1억이 넘으면
다른 알고리즘을 구상해봐야 한다.

2.128MB=3천
128MB에는 3천개의 int형 변수를 넣을 수 있다.
이를 통해 배열이나 자료구조를 고려할 때 최대 저장해야 하는 변수 수를 조정한다.



#배열, 연결 리스트

#정렬

#오버플로우, 언더플로우

#수학

#비트마스크(~07.18)

#완전탐색
1)입력 범위가 작고 (1억==1초)
2)전체 문제를 부분 문제로 쪼갤 수 있으며, 부분 문제를 푸는 데 
이전까지의 선택이 이후의 선택을 할 때 고려해야할 필요가 없을 경우(최적부분구조).
구현은 크게 두 가지 방법을 사용한다.
1)재귀(일반적으로 더 직관적) 2)반복문(일반적으로 더 빠름)


풀때 1)중복을 허용하는가? 2)순서가 고려되는가?
1-1)허용하면->처음부터 뽑는다.
1-2)허용 않으면->뽑혔던 것들을 전역 변수로 저장한다.(백트래킹)
2-1)고려되면->순열.
2-2)고려 안하면->조합. 순서를 고정한다.
특정 원소를 포함할지 말지 결정하는 문제(2^n 문제)도 완전탐색으로 풀 수 있다.



#백트래킹(~07.25)
1)완전탐색으로 풀수 있는 문제 중 
2)모든 순열이나 조합을 사전순으로 만들어야 하는 문제에 사용.
재귀로 모든 답을 차례로 만들며, 답이 완성되면 재귀 스택을 빼내 바로 이전으로 돌린다.

완전탐색의 일부로, 재귀로만 푼다.

속도를 줄이는 법으로 미리 원소를 캐싱하는 방법이 있는데
특정 원소가 선택되었는지 여부를 저장해둔다.
좌표계의 위치를 따질 때도 가로, 세로 등등 겹치는 것이 있는지 따로 저장한다.
대부분 전체 원소 개수 n의 배수만큼 빨라진다. 대신 메모리 초과 항상 확인

순열을 구하는 문제의 경우 next_permutation을 활용할 수 있다.
배열을 사전순으로 바로 다음에 해당하는 백트래킹 결과로 바꿔준다.
중복된 수도 잘 처리해주며, 
조합을 따질 때도 {0,0,0,1,1}과 같은 배열을 대신 사용하면 처리가 가능하다.

대표 유형 1) 겹치지 않는 체스말 문제
대표 유형 2) 순열, 조합 구하기



#분할정복
1)문제를 재귀함수로 분할이 용이하고,
2)분할된 문제가 원래 문제와 성격이 동일하고,
3)최소단위 문제를 쉽고 빠르게 풀 수 있는 경우 사용한다.

다음의 순서로 진행된다.
1)문제를 적절한 형태의 하위 문제로 더 이상 나눌 수 없을 때까지 나눈다.
2)최소 단위 문제의 해를 구한다.
3)구한 해를 나눈 순서대로 결합해가며 전체 답을 구한다.



#동적계획법(~8.1)
-최적 부분 구조
전체 문제를 같은 부분 문제로 조각냈을 때,
어느 부분 문제에 도달할 때까지 있었던 모든 선택이 이후의 선택에 영향을 주지 못하며
따라서 남은 부분 문제는 항상 최적으로 풀어도 상관 없는 문제 구조
즉 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 구할 수 있는 문제 구조

대표 유형 1) 01 배낭 문제
대표 유형 2) 최적화 문제
대표 유형 3) 경우의 수 구하기 문제
대표 유형 4) LIS
대표 유형 5) 반복적 동적 계획법
대표 유형 6) 위상 정렬
대표 유형 7) 편집 거리



#문자열
대표 유형 1) KMC 알고리즘



#스택/큐/덱
셋다 순차적으로 진행되는 문제에 주로 사용 ex) 초단위 계산, 절차대로 작업
스택 : 나중에 넣은것부터 변화를 줄 경우
큐 : 처음에 넣은것부터 변화를 줄 경우

대표 유형 1) 스택을 이용한 스위핑 알고리즘
대표 유형 2) 괄호 제거
대표 유형 3) 전위/중위/후위 표기식



#트리
정의 :
1)노드가 0개이거나
2)노드가 1개 이상이고 방향 간선이 존재할 경우
2-1)들어오는 간선이 하나도 없는 단 하나의 노드가 존재하고(루트 노드)
2-2)루트 노드를 제외한 모든 노드는 반드시 단 하나의 들어오는 간선이 존재하며
2-3)루트에서 다른 노드로 가는 경로는 반드시 존재하며, 유일하다. 
이는 루트를 제외한 모든 노드에 성립해야 한다.

루트 노드 찾기 :
만약 루트 노드가 주어지지 않는다면 직접 찾아야 한다.
간선 목록이 주어질 때 노드의 등장 횟수를 세어 노드나 리프의 여부를 판별할 수 있다.
루트 노드는 자식 노드로 등장하지 않으며, 
리프 노드는 부모 노드로 등장하지 않고 등장 횟수가 단 한번이다.

트리는 자체적으로 반복되는 구조를 가지므로 재귀, 분할정복을 활용하기 용이하다.
또한 트리는 그래프이기 때문에 이 특성을 잘 이용하자.

트리에서 층을 나눠 작업을 할 때 큐를 사용한다.
깊이순으로 루트부터 노드를 추가하고 싶다면 부모가 될 노드를 큐에 넣고,
부모를 바꿀때마다 pop하는 식으로 트리를 생성한다.

만약 문제를 풀다 도저히 알고리즘이 떠오르지 않는다면,
해당 문제를 트리로 표현해보고 적용할 수 있는 트리 알고리즘이 있는지 찾아본다.
문제를 알고 있는 자료구조로 치환해봐야 한다.

대표 유형 1) 전위/중위/후위 순회
대표 유형 2) 최소 공통 조상
대표 유형 3) DFS



#맵, 힙
1.맵
문자-숫자 짝으로 자료를 저장해야 할 때 사용.
그외에도 너무 자료형이 복잡해지면 사용.
맵은 자동으로 오름차순 정렬을 지원한다. sort 쓰지 말것.
탐색 방법 :
map<~,~> m;
if(m.find(key)==m.end()){//찾는 게 없는가?
    m.insert(make_pair(clothes[i][1],1));//없으면 넣고
}else{
    m[clothes[i][1]]++; //있으면 숫자 증가
}
순회 방법 :
map<~, ~>::iterator it;
for (it = m.begin(); it != m.end(); it++) {
    ~
}

2.힙(우선순위 큐)
: 원소 추가시마다 정렬을 새로 해야 할 경우 사용

우선순위 큐를 반으로 쪼개 두개의 우선순위큐를 만들고 서로 정렬을 반대 규칙으로 하면,
언제나 중앙값을 찾을 수 있는 우선순위큐를 만들 수 있다. 긴쪽의 탑. 
삽입시 양 쪽 탑을 비교해서 적절한 큐에 넣고, 최대값과 최소값은 루트를 탐색한다.



#그래프 탐색
V=정점, E=간선

만약 문제를 풀다 도저히 알고리즘이 떠오르지 않는다면,
해당 문제를 그래프로 표현해보고 적용할 수 있는 그래프 알고리즘이 있는지 찾아본다.
문제를 알고 있는 자료구조로 치환해봐야 한다.


그래프 표현 방법
1)인접 행렬
int Graph[start][end]
이중 배열을 이용해 각 인수를 출발,도착 노드 번호로 사용.
모든 노드간 관계를 전부 표현하며 공간복잡도가 O(V^2)으로 큰편.
간선 수가 많은 밀집 그래프에 적합.

2)인접 리스트
vector<int> Graph[node]
각 노드와 이어진 정점을 노드별로 전부 리스트에 저장.
두 노드간 간선을 모두 탐색해야 해서 시간복잡도가 O(V)만큼 소요.
간선 수가 적을수록 빨리 동작하므로 간선이 적은 희소 그래프에 적합.

3)간선 리스트
vector<vector<int>> Graph
간선을 기준으로 저장하는 방식.


그래프 탐색 방식
1)DFS
모든 정점을 방문해야 할 때 사용(방문할 필요 없는 정점 많으면 사용 x)
백트레킹과 많은 부분 겹쳐서 왠만해선 어렵게 안 나온다.

2)BFS
다음과 같은 경우 사용
1-가중치 없는 그래프에서 A->B로 가는 임의 최단 경로 탐색시.
2-어떤 물체의 상태(위치)가 계속 변화하는 경우
3-1씩 증가하는 경우(BFS는 탐색 시 노드의 깊이가 증가수열을 이룬다.)
큐를 이용. 그 외 격자가 등장하며 그래프로 접근해야 하면 무조건 BFS.

대표 유형 1) DFS
대표 유형 2) BFS



#최단경로
최단 경로 기법을 쓰기 전에, 그래프를 만들었을 때
1.상태 변화에 관련된 문제이거나
2.가중치가 0 혹은 1이거나
3.어떤 변화에 대한 확률 혹은 비용이 모두 같다면
BFS를 사용하면 최단 거리를 바로 구할 수 있다.

1)다익스트라(dijkstra)
어느 정점에서 가장 가까운 정점을 매 단계마다 찾아 
해당 정점을 거쳐 인접 정점들로 갔을 때 더 짧은 거리로 이동했는지 판별한다.
매 단계마다 선택되는 정점은 출발 지점에서 더 이상 짧은 경로를 발견할 수 없으므로,
이를 확정하고 기준으로 잡아 최단거리를 갱신해 다음 정점을 선택한다.

가중치가 모두 양수이고 모든 정점들의 관계를 구할 필요 없을 때 사용.
시간복잡도를 잘 고려하여 플로이드를 쓸 수 없으면 사용한다.

밀집 그래프가 아니면 무조건 힙으로 구현. 그래프는 인접 리스트 방식.
힙을 쓴 다익스트라의 시간복잡도는 O(VlogE)이므로 밀집 그래프가 아니라면
플로이드 한번 쓰는거보다 다익스트라를 정점 수만큼 쓰는 게 더 빠르다.

경로 복원시 pre 배열 선언 후 최단거리에서 직전에 방문한 정점 계속 업데이트

대표 유형 1) 다익스트라
대표 유형 2) 경로 복원
대표 유형 3) 다익스트라 or 플로이드


2)플로이드
모든 정점에 대해 해당 정점을 다른 정점들이 거쳐서 갈 경우에
경로가 더 짧아지는지를 일일이 비교하는 방식.
모든 정점에 대해 다른 모든 정점을 거쳐가는 경우를 구하므로
반드시 가장 짧은 경로를 구할 수 있다.

가중치가 모두 양수이고 모든 정점에 대한 최단거리 필요 시 사용.
for문 순서는 중간->시작->끝. 인접 배열 방식 사용.
시간복잡도가 O(V^3)이라 E<400일때만 사용. 밀집 그래프일경우 고민 없이 플로이드.
경로 복원시 이중배열 선언 후 최단거리에서 바로 다음에 방문해야할 정점 계속 업데이트.

대표 유형 1) 플로이드
대표 유형 2) 경로 복원
대표 유형 3) 우선순위 판별


3)벨만포드
다익스트라, 플로이드가 음수 간선이 안되는 이유:
매 단계에서 최단거리를 확정하지만, 확정된 최단 거리가 음수 가중치에 의해
확정이 되지 않는 순간 다익스트라 알고리즘의 전제가 깨지게 된다.

음수 간선이 존재할 경우 사이클이 발생하면 가중치가 무한히 작아질 수 있다.
따라서 벨만 포드에서 최단거리는 간선을 최대 |V|-1개까지만 선택할 수 있다. 

한 정점을 기준으로 한 최단거리를 구하고 싶을 때,
모든 정점들에 대해 각각의 인접한 정점으로 더 짧은 경로로 이동할 수 있는지 판별한다.
만약 정점의 최단거리가 아직 초기화되지 않았다면, 해당 정점은 해당 단계에서 무시한다.
이후 이를 |V|-1번 반복하면 가능한 모든 간선을 지나며 모든 최단거리를 알 수 있다.
그러나 만약 |V|번째에서 최단거리를 갱신했을때 값이 변경되었다면,
이는 그래프 안에 음수 사이클이 있다는 의미이므로 벨만 포드 알고리즘을 쓸 수 없다.

시간복잡도는 O(|V||E|), 밀집그래프일 경우 O(|V|^3)로,
가중치가 음수인 경우에만 사용한다. 인접 리스트 방식을 사용하는게 좋다.
또한 여러번 같은 계산을 수행하기 때문에 값이 기하급수적으로 커질 수 있으니,
자료형을 잘 선택하는 게 좋다.

또한 사이클 여부만을 확인하고 싶을 때는 시작 정점과 단절된 사이클까지 고려해야 한다.
이럴 경우 모든 정점을 직접 확인하면 시간 초과가 날 수 있으므로,
단절된 정점이 매우 큰 가중치로 이어져 있다고 가정하고 찾아야 한다.(INF 확인 없애기)

대표 유형 1) 벨만 포드
대표 유형 2) 사이클 확인



1.이진 탐색 트리

2.구간 트리 (세그먼트 트리)

3.상호 배타적 트리 (분리 집합 ,union-find)
집합 표현시 사용. 배열 하나 두고 해당 원소가 속한 원소의 집합의 대표 원소를 반환하는 배열 parent를 둬 해당 원소가 어디에 속하는지를 확인.
집합 표현할 때 쓰로 주로 최소 스패닝 트리 다룰 때 쓴다.
struct NaiveDisjointSet { 
    vector<int> parent; 
    NaiveDisjointSet(int n): parent(n) { 
        for (int i=0; i < n; i++) parent[i]=i; 
    } 
    int find (int u) { 
        if (u == parent[u]) return u;  
        return parent[u]=find(parent[u]); 
    } 
    bool merge (int u, int v){
        u = find(u); v = find(v); 
        if (u == v) return false; 
        parent[u] = v; 
        return true;
    } 
};

4.트라이

3.누적 합

4.비트마스크

5.문자열

6.정렬
sort 함수를 사용하면 된다.
펑터를 이용해 정렬 규칙을 바꿔 원하는 정렬 형태를 만들 수 있다.



#그래프


3.최소 스패닝 트리
1)크루스칼 최소 스패닝 트리
예시 : https://programmers.co.kr/learn/courses/30/lessons/42861
그리디 알고리즘의 대표 예시, 시간 복잡도 O(ElogE).
모든 정점이 연결된 경우가 아니라면 사용한다.
간선을 가중치 순으로 정렬하고, 간선을 n-1개만큼 선택한다.
이때 사이클이 발생하는 경우는 제외하고 선택해야 한다.
사이클을 판별할 때 유니온파인드 셋을 쓰면 간단하다.
각각의 정점이 하나의 집합이라고 생각하고, 간선으로 연결될 때마다 집합을 합친다.
만약 이미 합쳐진 두 정점을 선택할 경우 수를 세지 않는데,
이 과정이 유니온파인드의 merge 함수와 정확히 일치한다.
2)프림 최소 스패닝 트리
크루스칼과 비슷한 그리디 알고리즘.
모든 정점이 서로 연결된 경우에 크루스칼보다 빠르게 동작한다.
...추가바람

4.네트워크 유량


#탐욕법
모든 경우에 지금
각 단계에서 탐욕법으로 선택한 부분 문제의 최적해들을 포함하는 전체 최적해가 
항상 존재하면 해당 문제는 탐욕적 선택 속성이 있는 문제는
증명은 다음과 같이 진행
1)탐욕법이 "속성 A를 갖는 원소를 포함하는 최적해가 반드시 존재한다"라면
2)"속성 A를 갖지 않는 원소를 포함하는 최적해가 있다"고 가정
3)이후 둘을 비교하여 2)의 경우가 최적해라면 1)의 경우도 최적해가 되어야 함을 증명
탐욕법을 적용할 때 선택에 있어 손해를 볼 일이 없음을 증명한다
주로 나오는 유형
1)부분 배낭 문제
2)스케줄링 문제
3)최소 스패닝 트리





#정수, 기하
1)이분탐색
오버플로우 주의
최소값의 최댓값




#기타
스위핑 알고리즘

