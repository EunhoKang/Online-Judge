#기본 코드 작성

#시간복잡도

#배열, 연결 리스트

#수학

#정렬

#비트마스크

#

#완전탐색
1)입력 범위가 작고 (1억==1초)
2)전체 문제를 부분 문제로 쪼갤 수 있으며, 부분 문제를 푸는 데 
이전까지의 선택이 이후의 선택을 할 때 고려해야할 필요가 없을 경우(최적부분구조).
구현은 크게 두 가지 방법을 사용한다.
1)재귀(일반적으로 더 직관적) 2)반복문(일반적으로 더 빠름)


풀때 1)중복을 허용하는가? 2)순서가 고려되는가?
1-1)허용하면->처음부터 뽑는다.
1-2)허용 않으면->뽑혔던 것들을 전역 변수로 저장한다.(백트래킹)
2-1)고려되면->순열.
2-2)고려 안하면->조합. 순서를 고정한다.
특정 원소를 포함할지 말지 결정하는 문제(2^n 문제)도 완전탐색으로 풀 수 있다.



#백트래킹
1)완전탐색으로 풀수 있는 문제 중 
2)모든 순열이나 조합을 사전순으로 만들어야 하는 문제에 사용.
재귀로 모든 답을 차례로 만들며, 답이 완성되면 재귀 스택을 빼내 바로 이전으로 돌린다.

완전탐색의 일부로, 재귀로만 푼다.

속도를 줄이는 법으로 미리 원소를 캐싱하는 방법이 있는데
특정 원소가 선택되었는지 여부를 저장해둔다.
좌표계의 위치를 따질 때도 가로, 세로 등등 겹치는 것이 있는지 따로 저장한다.
대부분 전체 원소 개수 n의 배수만큼 빨라진다. 대신 메모리 초과 항상 확인

순열을 구하는 문제의 경우 next_permutation을 활용할 수 있다.
배열을 사전순으로 바로 다음에 해당하는 백트래킹 결과로 바꿔준다.
중복된 수도 잘 처리해주며, 
조합을 따질 때도 {0,0,0,1,1}과 같은 배열을 대신 사용하면 처리가 가능하다.

대표 유형 1) 겹치지 않는 체스말 문제
대표 유형 2) 순열, 조합 구하기



#분할정복
1)문제를 재귀함수로 분할이 용이하고,
2)분할된 문제가 원래 문제와 성격이 동일하고,
3)최소단위 문제를 쉽고 빠르게 풀 수 있는 경우 사용한다.

다음의 순서로 진행된다.
1)문제를 적절한 형태의 하위 문제로 더 이상 나눌 수 없을 때까지 나눈다.
2)최소 단위 문제의 해를 구한다.
3)구한 해를 나눈 순서대로 결합해가며 전체 답을 구한다.



#동적계획법
-최적 부분 구조
전체 문제를 같은 부분 문제로 조각냈을 때,
어느 부분 문제에 도달할 때까지 있었던 모든 선택이 이후의 선택에 영향을 주지 못하며
따라서 남은 부분 문제는 항상 최적으로 풀어도 상관 없는 문제 구조
즉 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 구할 수 있는 문제 구조

대표 유형 1) 01 배낭 문제
대표 유형 2) 최적화 문제
대표 유형 3) 경우의 수 구하기 문제
대표 유형 4) LIS
대표 유형 5) 반복적 동적 계획법
대표 유형 6) 위상 정렬
대표 유형 7) 편집 거리



#문자열
대표 유형 1) KMC 알고리즘



#스택/큐/덱
셋다 순차적으로 진행되는 문제에 주로 사용 ex) 초단위 계산, 절차대로 작업
스택 : 나중에 넣은것부터 변화를 줄 경우
큐 : 처음에 넣은것부터 변화를 줄 경우

대표 유형 1) 스택을 이용한 스위핑 알고리즘
대표 유형 2) 괄호 제거
대표 유형 3) 전위/중위/후위 표기식



#트리
정의 :
1)노드가 0개이거나
2)노드가 1개 이상이고 방향 간선이 존재할 경우
2-1)들어오는 간선이 하나도 없는 단 하나의 노드가 존재하고(루트 노드)
2-2)루트 노드를 제외한 모든 노드는 반드시 단 하나의 들어오는 간선이 존재하며
2-3)루트에서 다른 노드로 가는 경로는 반드시 존재하며, 유일하다. 
이는 루트를 제외한 모든 노드에 성립해야 한다.

루트 노드 찾기 :
만약 루트 노드가 주어지지 않는다면 직접 찾아야 한다.
간선 목록이 주어질 때 노드의 등장 횟수를 세어 노드나 리프의 여부를 판별할 수 있다.
루트 노드는 자식 노드로 등장하지 않으며, 
리프 노드는 부모 노드로 등장하지 않고 등장 횟수가 단 한번이다.

트리는 자체적으로 반복되는 구조를 가지므로 재귀, 분할정복을 활용하기 용이하다.
또한 트리는 그래프이기 때문에 이 특성을 잘 이용하자.

트리에서 층을 나눠 작업을 할 때 큐를 사용한다.
깊이순으로 루트부터 노드를 추가하고 싶다면 부모가 될 노드를 큐에 넣고,
부모를 바꿀때마다 pop하는 식으로 트리를 생성한다.

대표 유형 1) 전위/중위/후위 순회
대표 유형 2) 최소 공통 조상
대표 유형 3) 루트에서 리프로 DFS



#맵, 힙
1.맵
문자-숫자 짝으로 자료를 저장해야 할 때 사용.
그외에도 너무 자료형이 복잡해지면 사용.
맵은 자동으로 오름차순 정렬을 지원한다. sort 쓰지 말것.
탐색 방법 :
map<~,~> m;
if(m.find(key)==m.end()){//찾는 게 없는가?
    m.insert(make_pair(clothes[i][1],1));//없으면 넣고
}else{
    m[clothes[i][1]]++; //있으면 숫자 증가
}
순회 방법 :
map<~, ~>::iterator it;
for (it = m.begin(); it != m.end(); it++) {
    ~
}

2.힙(우선순위 큐)
: 원소 추가시마다 정렬을 새로 해야 할 경우 사용

우선순위 큐를 반으로 쪼개 두개의 우선순위큐를 만들고 서로 정렬을 반대 규칙으로 하면,
언제나 중앙값을 찾을 수 있는 우선순위큐를 만들 수 있다. 긴쪽의 탑. 
삽입시 양 쪽 탑을 비교해서 적절한 큐에 넣고, 최대값과 최소값은 루트를 탐색한다.



#그래프 탐색
그래프 표현 방법
1)인접 행렬
int Graph[start][end]
이중 배열을 이용해 각 인수를 출발,도착 노드 번호로 사용.
모든 노드간 관계를 전부 표현하며 공간복잡도가 O(V^2)으로 큰편.
간선 수가 많은 밀집 그래프에 적합.

2)인접 리스트
vector<int> Graph[node]
각 노드와 이어진 정점을 노드별로 전부 리스트에 저장.
두 노드간 간선을 모두 탐색해야 해서 시간복잡도가 O(V)만큼 소요.
간선 수가 적을수록 빨리 동작하므로 간선이 적은 희소 그래프에 적합.

3)간선 리스트
vector<vector<int>> Graph
간선을 기준으로 저장하는 방식.

그래프 탐색 방식
1)DFS
모든 정점을 방문해야 할 때 사용(방문할 필요 없는 정점 많으면 사용 x)
백트레킹과 많은 부분 겹쳐서 왠만해선 어렵게 안 나온다.

2)BFS
다음과 같은 경우 사용
1-가중치 없는 그래프에서 A->B로 가는 임의 최단 경로 탐색시.
2-어떤 물체의 상태(위치)가 계속 변화하는 경우
3-1씩 증가하는 경우(BFS는 탐색 시 노드의 깊이가 증가수열을 이룬다.)
큐를 이용.

대표 유형 1) DFS
대표 유형 2) BFS




1.이진 탐색 트리

2.구간 트리 (세그먼트 트리)

3.상호 배타적 트리 (분리 집합 ,union-find)
집합 표현시 사용. 배열 하나 두고 해당 원소가 속한 원소의 집합의 대표 원소를 반환하는 배열 parent를 둬 해당 원소가 어디에 속하는지를 확인.
집합 표현할 때 쓰로 주로 최소 스패닝 트리 다룰 때 쓴다.
struct NaiveDisjointSet { 
    vector<int> parent; 
    NaiveDisjointSet(int n): parent(n) { 
        for (int i=0; i < n; i++) parent[i]=i; 
    } 
    int find (int u) { 
        if (u == parent[u]) return u;  
        return parent[u]=find(parent[u]); 
    } 
    bool merge (int u, int v){
        u = find(u); v = find(v); 
        if (u == v) return false; 
        parent[u] = v; 
        return true;
    } 
};

4.트라이

3.누적 합

4.비트마스크

5.문자열

6.정렬
sort 함수를 사용하면 된다.
펑터를 이용해 정렬 규칙을 바꿔 원하는 정렬 형태를 만들 수 있다.



#그래프


2.최단경로
1)0-1 BFS (가중치 0-1일때만)
2)다익스트라
3)벨만포드
4)플로이드

3.최소 스패닝 트리
1)크루스칼 최소 스패닝 트리
예시 : https://programmers.co.kr/learn/courses/30/lessons/42861
그리디 알고리즘의 대표 예시, 시간 복잡도 O(ElogE).
모든 정점이 연결된 경우가 아니라면 사용한다.
간선을 가중치 순으로 정렬하고, 간선을 n-1개만큼 선택한다.
이때 사이클이 발생하는 경우는 제외하고 선택해야 한다.
사이클을 판별할 때 유니온파인드 셋을 쓰면 간단하다.
각각의 정점이 하나의 집합이라고 생각하고, 간선으로 연결될 때마다 집합을 합친다.
만약 이미 합쳐진 두 정점을 선택할 경우 수를 세지 않는데,
이 과정이 유니온파인드의 merge 함수와 정확히 일치한다.
2)프림 최소 스패닝 트리
크루스칼과 비슷한 그리디 알고리즘.
모든 정점이 서로 연결된 경우에 크루스칼보다 빠르게 동작한다.
...추가바람

4.네트워크 유량


#탐욕법
모든 경우에 지금
각 단계에서 탐욕법으로 선택한 부분 문제의 최적해들을 포함하는 전체 최적해가 
항상 존재하면 해당 문제는 탐욕적 선택 속성이 있는 문제는
증명은 다음과 같이 진행
1)탐욕법이 "속성 A를 갖는 원소를 포함하는 최적해가 반드시 존재한다"라면
2)"속성 A를 갖지 않는 원소를 포함하는 최적해가 있다"고 가정
3)이후 둘을 비교하여 2)의 경우가 최적해라면 1)의 경우도 최적해가 되어야 함을 증명
탐욕법을 적용할 때 선택에 있어 손해를 볼 일이 없음을 증명한다
주로 나오는 유형
1)부분 배낭 문제
2)스케줄링 문제
3)최소 스패닝 트리





#정수, 기하
1)이분탐색
오버플로우 주의
최소값의 최댓값




#기타
스위핑 알고리즘

