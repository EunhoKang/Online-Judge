

#완전탐색
1)입력 범위가 작고 (미리 시간복잡도를 계산해보고 억 단위 아래면 사용한다.)
2)전체 문제를 부분 문제로 쪼갤 수 있으며, 부분 문제를 푸는 데 
이전까지의 선택이 이후의 선택을 할 때 고려해야할 필요가 없다면 고려한다(최적부분구조).
재귀함수를 쓰는 게 일반적이다.

풀때 1)중복을 허용하는가? 2)순서가 고려되는가?
1)허용하면->처음부터 뽑는다.
2)허용 않으면->뽑혔던 것들을 저장한다.(전역변수 or DP)
2)고려되면->모든 경우를 뽑는다.
2)고려 안하면->중복을 피하기 위해 가장 앞에서부터 뽑고, 가장 앞을 변수로 정해둔다.


#기본 자료구조
1.해시
문자-숫자 짝으로 자료를 저장해야 할 때 사용
탐색 방법 :
map<~,~> m;
if(m.find(key)==m.end()){//찾는 게 없는가?
    m.insert(make_pair(clothes[i][1],1));//없으면 넣고
}else{
    m[clothes[i][1]]++; //있으면 숫자 증가
}

map<~, ~>::iterator it;
for (it = m.begin(); it != m.end(); it++) {
    ~
}
순회 방법 :
map<~, ~>::iterator it;
for (it = m.begin(); it != m.end(); it++) {
    ~
}

2.스택/큐/우선순위큐(힙)
셋다 순차적으로 진행되는 문제에 주로 사용 ex) 초단위 계산, 절차대로 작업
스택 : 나중에 넣은것부터 변화를 줄 경우
큐 : 처음에 넣은것부터 변화를 줄 경우
우선순위큐(힙) : 원소 추가시마다 정렬을 새로 해야 할 경우
우선순위 큐를 반으로 쪼개 두개의 우선순위큐를 만들고 서로 정렬을 반대 규칙으로 하면,언제나 중앙값을 찾을 수 있는 우선순위큐를 만들 수 있다. 긴쪽의 탑. 삽입시 양 쪽 탑을 비교해서 적절한 큐에 넣고, 최대값과 최소값은 루트를 탐색한다.

3.부분 합, 누적 합

4.비트마스크

5.문자열

6.정렬
sort 함수를 사용하면 된다.
펑터를 이용해 정렬 규칙을 바꿔 원하는 정렬 형태를 만들 수 있다.


#트리
1.이진 탐색 트리

2.구간 트리 (세그먼트 트리)

3.상호 배타적 트리 (분리 집합 ,union-find)
집합 표현시 사용. 배열 하나 두고 해당 원소가 속한 원소의 집합의 대표 원소를 반환하는 배열 parent를 둬 해당 원소가 어디에 속하는지를 확인.
집합 표현할 때 쓰로 주로 최소 스패닝 트리 다룰 때 쓴다.
struct NaiveDisjointSet { 
    vector<int> parent; 
    NaiveDisjointSet(int n): parent(n) { 
        for (int i=0; i < n; i++) parent[i]=i; 
    } 
    int find (int u) { 
        if (u == parent[u]) return u;  
        return parent[u]=find(parent[u]); 
    } 
    bool merge (int u, int v){
        u = find(u); v = find(v); 
        if (u == v) return false; 
        parent[u] = v; 
        return true;
    } 
};

4.트라이



#그래프

1.DFS/BFS
1)DFS
모든 정점을 방문해야 할 때 사용(방문할 필요 없는 정점 많으면 사용 x)
재귀적으로 구현, 백 트레킹 방식->반드시 활용할 것

2)DFS
A->B로 가는 임의 최단 경로 탐색시 사용
큐를 이용할 것

2.최단경로
1)0-1 BFS (가중치 0-1일때만)
2)다익스트라
3)벨만포드
4)플로이드

3.최소 스패닝 트리
1)크루스칼 최소 스패닝 트리
예시 : https://programmers.co.kr/learn/courses/30/lessons/42861
그리디 알고리즘의 대표 예시, 시간 복잡도 O(ElogE).
모든 정점이 연결된 경우가 아니라면 사용한다.
간선을 가중치 순으로 정렬하고, 간선을 n-1개만큼 선택한다.
이때 사이클이 발생하는 경우는 제외하고 선택해야 한다.
사이클을 판별할 때 유니온파인드 셋을 쓰면 간단하다.
각각의 정점이 하나의 집합이라고 생각하고, 간선으로 연결될 때마다 집합을 합친다.
만약 이미 합쳐진 두 정점을 선택할 경우 수를 세지 않는데,
이 과정이 유니온파인드의 merge 함수와 정확히 일치한다.
2)프림 최소 스패닝 트리
크루스칼과 비슷한 그리디 알고리즘.
모든 정점이 서로 연결된 경우에 크루스칼보다 빠르게 동작한다.
...추가바람

4.네트워크 유량




#동적계획법
-최적 부분 구조
전체 문제를 같은 부분 문제로 조각냈을 때,
어느 부분 문제에 도달할 때까지 있었던 모든 선택이 이후의 선택에 영향을 주지 못하며
따라서 남은 부분 문제는 항상 최적으로 풀어도 상관 없는 문제 구조
즉 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 구할 수 있는 문제 구조



#탐욕법
모든 경우에 지금
각 단계에서 탐욕법으로 선택한 부분 문제의 최적해들을 포함하는 전체 최적해가 
항상 존재하면 해당 문제는 탐욕적 선택 속성이 있는 문제는
증명은 다음과 같이 진행
1)탐욕법이 "속성 A를 갖는 원소를 포함하는 최적해가 반드시 존재한다"라면
2)"속성 A를 갖지 않는 원소를 포함하는 최적해가 있다"고 가정
3)이후 둘을 비교하여 2)의 경우가 최적해라면 1)의 경우도 최적해가 되어야 함을 증명
탐욕법을 적용할 때 선택에 있어 손해를 볼 일이 없음을 증명한다
주로 나오는 유형
1)부분 배낭 문제
2)스케줄링 문제
3)최소 스패닝 트리

#분할정복





#정수, 기하
1)이분탐색
오버플로우 주의
최소값의 최댓값




#기타

